# Хэш-Таблица и её оптимизации

## Что такое хэш-таблица и не только

### Хэш-функция
Это функция, которая получает ключ и возвращает хэш. Ключом может быть любой тип данных: число или строка, например. Хэш тоже может быть любым нужным типом данных, обычно, это число. Если хэш-функция должна вернуть два одинаковых хэша, получив одинаковые ключи.

Например ($hash = key$) уже хэш функция!

### Действия
В хэш-таблице хранятся пары (ключ; значение), которые можно:

1. Вставить пару
2. Удалить пару
3. Найти пару

По своей сути, хэш-таблица - это прокачанный массив, в котором поиск происходит за $O(1)$ в лучшем случае и $O(n)$ в худшем (когда много коллизий). Это гораздо быстрее массива
### Коллизии
Простыми словами: получение одинакового хэша при хэшировании разных ключей
### Как с ними бороться?
Есть много способов: открытое хэширование, кукушкино, идеальное (если статическое количество ключей), но в этой работе остановимся на закрытом, оно же хэширование цепочками:

Ячейками хэш-таблицы являются односвязные списки, в каждом списке хранятся ключи с одинаковым хэшем и, при поиске, происходит переход по элементам этого списка, пока не найдём нужный ключ

### Load factor
Или же коэффициент загруженности - это отношение размера таблицы к её текущей вместимости. Чем он больше, тем больше вероятность коллизий, что, разумеется, плохо, тк ведёт к увеличению времени действий. А хэширование цепочками позволяет достичь больших значений этого коэффициента.

 При достижении выбранного коэффициента, таблица рехэшируется, то есть её вместимость увеличивается и заново считаются хэши для ключей в таблице.
## Основная работа

### Суть и мотивация
С хэш-таблицей всё ясно, это более быстрый массив, но что, если сделать коэффициент загрузки просто огромным (например 16), искусственно увелчивая время действий, и попытаться оптимизировать её? В этом и состоит эта работа.

### Скорость программы
Ключевое правило: скорость программы определяется её самым медленным участком. Но как его найти?

Для этого будем использовать perf! А точнее некоторые из её функций:

1. perf top (открыв во одной консоли, а запустив программу в другой, можно в реальном времени смотреть, какая из функций сколько процентов процессора потребляет)

2. perf record -g ./<название программы> && perf report (вторая консоль не нужна, покажет те же данные, только статично, более подбробно и измеренные на протяжении всей программы)

### Методы оптимизации
В этом семестре мной было изучено несколько способов отпимизации фукнций, а точнее переписать её, используя:

1. Ассемблер (Я использую nasm x86_64)
2. Векторные инструкции (они же интринсики, вплоть до AVX2)
3. Встроенный ассемблер

### Важно понимать!!!
Оптимизации - это круто, очень круто, но есть большое НО: чем больше строк на ассемблере или использующих векторные инструкции, тем менее читаем код, потому нужно следить за большим значением эффективности $\mu = \frac{ускорение}{строки}$, то есть, если программа была ускорена на $0,001$% с помощью $1000$ строк на ассемблере, то оптимизация не блещет эффективностью

### Измерение
Возьмём большой текст (я взял Войну и мир на английском) и будем вставлять пословно в таблицу, при этом ища на этом шаге случайныую строку:


    for (size_t i = 0; i < read->count_words; i++)
        {
            Insert(table, read->words[i]);

            int random = rand() % 32;
            char *rand_str = RandString(random);

            Search(table, rand_str);

            free(rand_str);
        }

Где read->count_words - считанное из файла с текстом количество слов

Зпустив: perf record -g ./HashTable && perf report, получим:
![alt text](Pictures/Report1.png)

Значит, нужно оптимизировать поиск и вставку

Замерим общее время с помощью perf stat ./HashTable
![alt text](Pictures/Stat1.png)


Протестировав 7 раз с помощью perf stat, получим средний результат:
|   Номер теста |   1    |   2    |   3    |   4    |   5    |   6    |   7    |
|---------------|--------|--------|--------|--------|--------|--------|--------|
|   время       |731.58  |742.64  |725.16  |761.91  |715.67  |716.14  |766.84  |

Среднее значение: $737.13$ ms

## Ускоряемся!